{"pageProps":{"frontmatter":{"slug":"/blog/3-must-haves-for-slicing-monolith-frontend","date":"2023-03-28","title":"3 Must-Have Prerequisites for Slicing Monolith","socialImage":"social-img/3-microfrontend-principles.png","draft":false},"content":"\n## (Frontend journey through Digital Transformation)\n\nOnce a startup has validated the profitability of its idea, \nit typically evolves into a mid-sized company, \nhaving moved rapidly from inception to this point. \nThe product and brand are now well-established in the market, \nbut the next challenge is to compete effectively by adding new features. \nHowever, the technology underpinning the product \ncan become a significant obstacle - a big ball of mud, also known as a monolith.\n\nDespite the company's stable position in the market,\nthe need to deliver new features rapidly has only intensified. \nHowever, there are several challenges hindering progress: \nfirstly, the company has accrued significant technical debt \ndue to its focus on fast prototyping and organic growth; \nsecondly, poor architectural decisions have led to siloed \nand problematic systems; \nand thirdly, customer needs have evolved since the company's inception, \nnecessitating a more responsive approach. \n\nThese challenges can only be met by embarking on a gradual digital transformation, \nmigrating the risky and hard-to-change technical stack \nto better align with business needs \nwhile simultaneously streamlining it for future adaptability\nat the same time ensuring smooth execution of existing business.\n\nMonoliths can pose significant risks, \nas they often become difficult and slow to change over time. \nMaking changes to a monolithic architecture \ntypically requires extensive testing and development cycles, \nleading to delays in time-to-market and the risk of \nintroducing new bugs or technical debt. \n\n*Vertical slicing* is a technique that addresses these issues \nby breaking down a monolith into smaller, more manageable pieces, \nwhich can be developed and tested independently. \nBy focusing on one vertical slice at a time, \ndevelopment teams can streamline development cycles\nand introduce new features and capabilities more rapidly. \nIt's no surprise, then, that vertical slicing is often \nat the core of digital transformation efforts.\n\nWe have become adept at implementing bounded contexts \nand slicing monoliths into microservices in the backend. \nOver the past two decades, \nwe have learned how to create scalable and maintainable architectures, \nleveraging buzzwords such as \nCloud, scalability, CI/CD Pipelines, High availability, \nCQRS, Messaging, Domains, Context Mapping, Caching, and more. \nHowever, while we have established a stable set of best practices in the backend, \nthe frontend and user experience part has often been neglected.\n\nLuckily, over the past several years, \nthere have been significant developments in the user-facing area as well.\nNew best practices have emerged and become more stable, \nallowing for better user experiences and front-end development.\nFrom my experience, I can see three main aspects \nthat have had the biggest impact \non improving the front-end development process and user experience: \nmicrofrontends, single sign-on, and design systems. \nThese aspects have become crucial prerequisites in achieving a successful digital transformation.\n\n### 1. Microfrontends\n\nMicroservices are all about the backend, \nbut historically we didn't have a clear trend \nfor how to do vertical slicing in the frontend. \nIt wasn't clear if we should go with *server-side includes*, \nor *client-side includes*, (and hopefully not with iframes).\n\nThere were some attempts by companies to organize frontend development \nthat have emerged in recent years:\n\n  - *Zalando Tailor*: This is a microfrontend framework developed by Zalando, \n    the European online fashion retailer. \n    Tailor allows for the creation of independent microfrontends \n    that can be integrated into a single page using server-side composition. \n    It also includes features such as shared dependencies, \n    state management, and cross-microfrontend communication.\n\n  - *Spotify Backstage*: Backstage is an open-source platform developed by Spotify \n    to manage their internal tooling and services. \n    It includes a plugin system for adding custom features \n    and a frontend development kit called Backstage-UI, \n    which follows a microfrontend architecture.\n\n  - *Bit*: Bit is an open-source tool \n    for sharing and reusing React components across projects. \n    It allows you to build, test, and deploy individual components, \n    making it easier to manage your codebase and collaborate with other developers.\n\n  - *Open Components*: Open Components is a platform-agnostic library \n    of reusable UI components built with modern web technologies. \n    It provides a set of building blocks for building web applications, \n    making it easier to maintain consistency across your codebase.\n\nJavaScript-based single-page apps have become the norm in web development, \nand regardless of which framework is in use (Angular/React/Vue or any other), \nthey all rely on Webpack. \n\nAs of version 5, Webpack now supports **Federated Modules**, \nwhich is becoming the next big thing \ngiven its strategically-centered position within the JavaScript ecosystem. \n\nI think that Federated Modules will become the dominant way\nof organizing frontend applications \ninto separately released microfrontends for several reasons. \n\n1. It is *framework agnostic* and can integrate at the DOM level using browser APIs,\n  making it adaptable to different projects and technologies (Angular/React/Vue/others);\n2. It supports *state management* and communication channels between microfrontends, \n   making it easier to maintain consistency and coherence across different components;\n3. Webpack has a unique position in the ecosystem,\n   and Federated Modules have *strong community support*, \n   which means that it will continue to improve and evolve over time;\n4. Federated Modules are *very well designed*, making it easy to use and understand,\n   even for developers who are new to the concept of microfrontends.\n\n### Single Sign-On (SSO)\n\nOne of the most obvious challenges that arise when we slice \nour monolithic user experience into microfrontends \nis the need to direct users from one domain to another \nwhile interacting with the system. \nIn most cases, these domains are hosted on different microfrontends, \nwhich means that users would need to log in separately \nto each of the systems they interact with. \n\nThis is where Single Sign-on (SSO) comes into play. \nSSO enables users to jump from one frontend app to another \nwithout the need to log in to each system separately. \nWith SSO, users can authenticate once and access multiple applications \nwithout the need to repeat the login process. \n\nThis is not a new problem, \nsince we had distributed systems and third party integrations since forever.\nIn the past, SSO was often seen as a complex and challenging task, \nrequiring a lot of custom development work. However, in recent years, \nthere has been a growing trend towards standardization and simplification in this area.\nMany popular identity providers, such as Google, Facebook, and Microsoft, \nnow offer easy-to-use APIs and SDKs for implementing SSO. \nIn addition, there are now many open-source and commercial solutions available \nfor implementing SSO, such as Auth0, Okta, and Keycloak, \nwhich can greatly simplify the task \nof integrating SSO into a microfrontends architecture. \nAs a result, SSO has become more accessible \nand easier to implement than ever before.\n\nUsing off-the-shelf solutions that adhere to industry standards \nis highly recommended in the context of Microfrontends development. \nIn contrast, rolling out your own Sign-On solution \nmay not align with the Microfrontends approach to software development \nand could be perceived as a not-invented-here fallacy.\n\nDealing with extensive security and regulatory requirements is a challenging task, \nand rolling out your own Sign-On solution would require a tremendous amount of work. \nImplementing multi-factor authentication (MFA), user registration, management, \nand reset password scenarios could be time-consuming, \nand it's crucial to adhere to regulations such as Open Banking and GDPR, \nwhere security is paramount. \nIt's important to store user PPI (Personally Identifiable Information) \nin a single place, and using an off-the-shelf solution \nthat complies with these regulations can save a lot of time and resources.\n\nUsing a standard compliant SSO server also provides the advantage \nof easy substitution with an alternative solution \nthat adheres to the same standards. In addition, \nhaving a standard compliant SSO server makes it easier \nto test and compare different solutions. \nFor instance, I created an [OAuth Testbed](https://oauth-testbed.luke10x.com/)\nweb application that can be used to test swapping one \nOpenID Connect compliant solution for another.\n\n### 3. Design Systems\n\nDesign Systems have become an essential part of modern software development.\nThey provide a consistent set of visual and functional elements \nthat can be reused across multiple products, or in our case across several Microfrontends.\n\nDesign systems offer several advantages, including:\n\n- *Rapid application development*: Developers can quickly create new features \n  and components without needing to involve designers \n  in every aspect of the development process. \n- *Consistent look and feel* for the entire user journey, \n  which is especially important when users interact with multiple applications \n  or platforms from the same brand or organization. \n- Adhere to *accessibility* guidelines and best practices \n  that can help developers create interfaces \n  that are easy to use for people with disabilities.\n\nA component library lies at the core of a Design System. \nIt offers a set of pre-designed UI components \nthat can be utilized in multiple applications.\nThere are many popular component libraries available in the market, \nsome of which include:\n\n- *Material-UI*: one of the most popular React component libraries \n  based on Google's Material Design system. \n  It provides a rich set of pre-built components, \n  including buttons, forms, typography, and icons.\n- *Bootstrap*: one of the oldest and most popular component libraries. \n  It provides a set of CSS and JavaScript components for building responsive, \n  mobile-first web applications.\n- *Ant Design*: a popular Chinese React UI library \n  that provides a set of high-quality components and a clean design system. \n  It includes components like buttons, forms, navigation, and data visualization.\n- *Semantic UI*: a comprehensive component library \n  that provides a semantic and responsive design system.\n  It includes a wide range of components, including buttons, forms, and layouts.\n- *Chakra UI*: a popular React component library \n  that provides a set of accessible and customizable components. \n  It includes components like buttons, forms, and typography.\n\nAs the demand for scalable and consistent design systems grows,\nI predict that we will see an increase in the number \nof component libraries available. \nDespite the popularity of existing component libraries, \neach has its own limitations and drawbacks.\n\nDesign system discussions often include mentioning \n[Storybook](https://storybook.js.org). \nStorybook is an open-source tool for building UI components and pages in isolation. \nIt provides a sandboxed environment where developers can experiment with components \nand see how they interact with different data sets and states.\n\nIt's not uncommon to see companies over-invest in their design system, \nwhich can lead to wasted resources and slow down development. \nTherefore, it's crucial for companies \nto make a realistic assessment of their capabilities \nand needs before embarking on a design system project. \nIt's important to consider factors such as the size of the company, \nthe complexity of the application, the available resources, \nand the overall business goals.\n\nFor some lean enterprises, having a CSS toolkit like \n[TailwindCSS](https://tailwindcss.com/) \ncould be sufficient for their needs. \nTailwindCSS provides a set of pre-designed CSS classes \nthat can be used to style UI components quickly \nand consistently across applications. \n\n- *Utility-first approach*: TailwindCSS follows a utility-first approach, \n  which means that it provides a set of pre-defined classes \n  for common styles and layout, \n  allowing developers to quickly style their components \n  by applying classes rather than writing custom CSS.\n- *Customization*: TailwindCSS allows developers to easily customize \n  their styles by modifying the default theme or creating a new one. \n  This provides greater flexibility \n  and control over the design of the application.\n- *Size*: TailwindCSS is significantly smaller in size compared to Bootstrap,\n  which means that it can be loaded faster \n  and has a smaller footprint on the application. \n  This can be especially important for applications \n  that prioritize performance and speed.\n\nOne of the aspects I particularly admire about TailwindCSS \nis its utility-first approach. \nThis approach challenges the traditional \"separation of concerns\" principle \nby promoting a more pragmatic \"principle of collocation\". \nWith TailwindCSS, the styles are defined directly in the markup,\nand it also encourages extracting reusable components.\n"},"__N_SSG":true}