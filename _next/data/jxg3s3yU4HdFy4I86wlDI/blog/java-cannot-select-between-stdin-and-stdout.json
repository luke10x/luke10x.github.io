{"pageProps":{"frontmatter":{"slug":"/blog/java-cannot-select-between-stdin-and-stdout","date":"2023-04-07","title":"Java Selector cannot be used for stdin/stdout","socialImage":"social-img/java-selector.png","draft":false},"content":"\nWell, I must say, I'm quite irate about this whole situation with Java \nand its inability to listen for stdin and stdout of a running process \nand turn them into SelectableChannels that can be registered to a Selector. \nIt's just downright frustrating, especially given how useful SelectableChannel\ncan be in other contexts.\n\nI was attempting to write a program that could interact with a long-running process \nby reading and writing to its stdin and stdout streams. \nAnd I was hoping to use selectable channels to do this in a single thread, \nrather than having to spin up multiple threads or use callbacks.\n\n    // Start the long-running process\n    Process p = Runtime.getRuntime().exec(\"myLongRunningProcess\");\n\n    // Get the process's stdin and stdout streams\n    OutputStream stdin = p.getOutputStream();\n    InputStream stdout = p.getInputStream();\n\n    // Wrap the streams in channels (which doesn't work!)\n    SelectableChannel stdinChannel = Channels.newChannel(stdin);\n    SelectableChannel stdoutChannel = Channels.newChannel(stdout);\n\n    // Create a selector and register the channels\n    Selector selector = Selector.open();\n    stdinChannel.register(selector, SelectionKey.OP_READ);\n    stdoutChannel.register(selector, SelectionKey.OP_READ);\n\n    // Wait for messages on either channel\n    while (true) {\n        selector.select();\n        Set<SelectionKey> selectedKeys = selector.selectedKeys();\n        for (SelectionKey key : selectedKeys) {\n            if (key.isReadable()) {\n                // Handle input from the selected channel\n                if (key.channel() == stdinChannel) {\n                    // Long running process has typed something on stdin\n                } else if (key.channel() == stdoutChannel) {\n                    // Long-running process has written to stdout\n                }\n            }\n        }\n    }\n\nAs you can see, the code is fairly straightforward, but unfortunately, \nthe part where we try to wrap the process's stdin and stdout streams \nin selectable channels simply doesn't work.\n\nWe're left with no choice but to resort to using threads or callbacks\nto handle input and output from the process (I learned the hard way).\n\nYes, it's great that my search was finally over once I read an answer to\n[this question on Stack Overflow](https://stackoverflow.com/questions/39931485/java-process-read-stdout-and-stderr-of-a-subprocess-in-a-single-thread/39932773), \neven if the outcome was unsatisfying in the sense that the approach I had initially hoped to use didn't work out.\n\nI've found an easy option using CompletableFutures to solve the problem:\n\n    Process p = Runtime.getRuntime().exec(commandArgs);\n    CompletableFuture<String> errFut = readStderr(p.getErrorStream());\n    CompletableFuture<String> outFut = readStderr(p.getInputStream());\n\nAnd that `readStderr` method is using CompletableFutures\nto asynchronously read from an input stream, like this:\n\n    static CompletableFuture<String> readStderr(InputStream is) {\n        Executor sameThreadExecutor = Runnable::run;\n\n        return CompletableFuture.supplyAsync(() -> {\n            try (\n                InputStreamReader isr = new InputStreamReader(is);\n                BufferedReader br = new BufferedReader(isr);\n            ) {\n                StringBuilder res = new StringBuilder();\n                String inputLine;\n                while ((inputLine = br.readLine()) != null) {\n                    res.append(inputLine).append(System.lineSeparator());\n                    log.info(\"ERRRRRR {}:{}\", tag, inputLine);\n                }\n                return res.toString();\n            } catch (Throwable e) {\n                throw new RuntimeException(\"problem with executing program\", e);\n            }\n        }, sameThreadExecutor);\n    }\n\nSince we're using the same executor for both stdout and stderr streams,\nthe stdout reading will be blocked until the stderr reading is finished. \nThis is because the same thread is executing both tasks.\n\nIf the second argument is not provided for the call to CompletableFuture.supplyAsync, \nthe default executor for async tasks will be used. \nThis default executor is based on the `ForkJoinPool.commonPool()` executor, \nwhich is shared across multiple CompletableFuture instances.\n\nThis way the stdin and stdout will be read in parallelel, but doing this will block 2 threads.\nIn general, blocking threads can be a serious limitation for high-performance applications, \nsince it can limit the overall throughput of the system. \n\nthere is still no way to create SelectableChannels from stdin and stdout streams. \nThe SelectableChannel abstraction is a powerful feature of the java.nio package, \nsince it allows you to efficiently manage I/O operations \nacross multiple channels using a single thread.\nIt's not clear why this functionality hasn't been added to the standard library yet.\n"},"__N_SSG":true}