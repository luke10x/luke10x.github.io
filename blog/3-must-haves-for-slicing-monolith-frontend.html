<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="shortcut icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; 
          viewBox=&#x27;0 0 100 100&#x27;
          %3E%3Ccircle 
          cx=&#x27;50&#x27; cy=&#x27;50&#x27; r=&#x27;50&#x27; fill=&#x27;%23ff33ff&#x27; /%3E%3C/svg%3E"/><link rel="preload" href="/_next/static/css/f74e7403dfc41554.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f74e7403dfc41554.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-cda2f1305c3d9424.js" defer=""></script><script src="/_next/static/chunks/main-83cebdb887f48834.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6257153885dc7086.js" defer=""></script><script src="/_next/static/chunks/980-500204586efa6805.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-16f621665fa931ac.js" defer=""></script><script src="/_next/static/jxg3s3yU4HdFy4I86wlDI/_buildManifest.js" defer=""></script><script src="/_next/static/jxg3s3yU4HdFy4I86wlDI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="flex flex-col min-h-screen"><header class="bg-slate-200 mb-8 py-4"><div class="container mx-auto flex justify-center"><div><a href="/"><h1 class="text-black font-roboto text-5xl mb-2">LUKE 10X</h1><span class="block text-center text-gray-500 text-xxs block">FULLSTACK DEVELOPER &amp; CODE INSTRUCTOR</span></a></div><span class="mx-auto"></span> </div></header><main class="container mx-auto flex-1"><div class="prose mx-auto"><h1>3 Must-Have Prerequisites for Slicing Monolith</h1><div class="flex flex-wrap gap-2">2023-03-28</div><div><h2>(Frontend journey through Digital Transformation)</h2>
<p>Once a startup has validated the profitability of its idea,
it typically evolves into a mid-sized company,
having moved rapidly from inception to this point.
The product and brand are now well-established in the market,
but the next challenge is to compete effectively by adding new features.
However, the technology underpinning the product
can become a significant obstacle - a big ball of mud, also known as a monolith.</p>
<p>Despite the company's stable position in the market,
the need to deliver new features rapidly has only intensified.
However, there are several challenges hindering progress:
firstly, the company has accrued significant technical debt
due to its focus on fast prototyping and organic growth;
secondly, poor architectural decisions have led to siloed
and problematic systems;
and thirdly, customer needs have evolved since the company's inception,
necessitating a more responsive approach.</p>
<p>These challenges can only be met by embarking on a gradual digital transformation,
migrating the risky and hard-to-change technical stack
to better align with business needs
while simultaneously streamlining it for future adaptability
at the same time ensuring smooth execution of existing business.</p>
<p>Monoliths can pose significant risks,
as they often become difficult and slow to change over time.
Making changes to a monolithic architecture
typically requires extensive testing and development cycles,
leading to delays in time-to-market and the risk of
introducing new bugs or technical debt.</p>
<p><em>Vertical slicing</em> is a technique that addresses these issues
by breaking down a monolith into smaller, more manageable pieces,
which can be developed and tested independently.
By focusing on one vertical slice at a time,
development teams can streamline development cycles
and introduce new features and capabilities more rapidly.
It's no surprise, then, that vertical slicing is often
at the core of digital transformation efforts.</p>
<p>We have become adept at implementing bounded contexts
and slicing monoliths into microservices in the backend.
Over the past two decades,
we have learned how to create scalable and maintainable architectures,
leveraging buzzwords such as
Cloud, scalability, CI/CD Pipelines, High availability,
CQRS, Messaging, Domains, Context Mapping, Caching, and more.
However, while we have established a stable set of best practices in the backend,
the frontend and user experience part has often been neglected.</p>
<p>Luckily, over the past several years,
there have been significant developments in the user-facing area as well.
New best practices have emerged and become more stable,
allowing for better user experiences and front-end development.
From my experience, I can see three main aspects
that have had the biggest impact
on improving the front-end development process and user experience:
microfrontends, single sign-on, and design systems.
These aspects have become crucial prerequisites in achieving a successful digital transformation.</p>
<h3>1. Microfrontends</h3>
<p>Microservices are all about the backend,
but historically we didn't have a clear trend
for how to do vertical slicing in the frontend.
It wasn't clear if we should go with <em>server-side includes</em>,
or <em>client-side includes</em>, (and hopefully not with iframes).</p>
<p>There were some attempts by companies to organize frontend development
that have emerged in recent years:</p>
<ul>
<li>
<p><em>Zalando Tailor</em>: This is a microfrontend framework developed by Zalando,
the European online fashion retailer.
Tailor allows for the creation of independent microfrontends
that can be integrated into a single page using server-side composition.
It also includes features such as shared dependencies,
state management, and cross-microfrontend communication.</p>
</li>
<li>
<p><em>Spotify Backstage</em>: Backstage is an open-source platform developed by Spotify
to manage their internal tooling and services.
It includes a plugin system for adding custom features
and a frontend development kit called Backstage-UI,
which follows a microfrontend architecture.</p>
</li>
<li>
<p><em>Bit</em>: Bit is an open-source tool
for sharing and reusing React components across projects.
It allows you to build, test, and deploy individual components,
making it easier to manage your codebase and collaborate with other developers.</p>
</li>
<li>
<p><em>Open Components</em>: Open Components is a platform-agnostic library
of reusable UI components built with modern web technologies.
It provides a set of building blocks for building web applications,
making it easier to maintain consistency across your codebase.</p>
</li>
</ul>
<p>JavaScript-based single-page apps have become the norm in web development,
and regardless of which framework is in use (Angular/React/Vue or any other),
they all rely on Webpack.</p>
<p>As of version 5, Webpack now supports <strong>Federated Modules</strong>,
which is becoming the next big thing
given its strategically-centered position within the JavaScript ecosystem.</p>
<p>I think that Federated Modules will become the dominant way
of organizing frontend applications
into separately released microfrontends for several reasons.</p>
<ol>
<li>It is <em>framework agnostic</em> and can integrate at the DOM level using browser APIs,
making it adaptable to different projects and technologies (Angular/React/Vue/others);</li>
<li>It supports <em>state management</em> and communication channels between microfrontends,
making it easier to maintain consistency and coherence across different components;</li>
<li>Webpack has a unique position in the ecosystem,
and Federated Modules have <em>strong community support</em>,
which means that it will continue to improve and evolve over time;</li>
<li>Federated Modules are <em>very well designed</em>, making it easy to use and understand,
even for developers who are new to the concept of microfrontends.</li>
</ol>
<h3>Single Sign-On (SSO)</h3>
<p>One of the most obvious challenges that arise when we slice
our monolithic user experience into microfrontends
is the need to direct users from one domain to another
while interacting with the system.
In most cases, these domains are hosted on different microfrontends,
which means that users would need to log in separately
to each of the systems they interact with.</p>
<p>This is where Single Sign-on (SSO) comes into play.
SSO enables users to jump from one frontend app to another
without the need to log in to each system separately.
With SSO, users can authenticate once and access multiple applications
without the need to repeat the login process.</p>
<p>This is not a new problem,
since we had distributed systems and third party integrations since forever.
In the past, SSO was often seen as a complex and challenging task,
requiring a lot of custom development work. However, in recent years,
there has been a growing trend towards standardization and simplification in this area.
Many popular identity providers, such as Google, Facebook, and Microsoft,
now offer easy-to-use APIs and SDKs for implementing SSO.
In addition, there are now many open-source and commercial solutions available
for implementing SSO, such as Auth0, Okta, and Keycloak,
which can greatly simplify the task
of integrating SSO into a microfrontends architecture.
As a result, SSO has become more accessible
and easier to implement than ever before.</p>
<p>Using off-the-shelf solutions that adhere to industry standards
is highly recommended in the context of Microfrontends development.
In contrast, rolling out your own Sign-On solution
may not align with the Microfrontends approach to software development
and could be perceived as a not-invented-here fallacy.</p>
<p>Dealing with extensive security and regulatory requirements is a challenging task,
and rolling out your own Sign-On solution would require a tremendous amount of work.
Implementing multi-factor authentication (MFA), user registration, management,
and reset password scenarios could be time-consuming,
and it's crucial to adhere to regulations such as Open Banking and GDPR,
where security is paramount.
It's important to store user PPI (Personally Identifiable Information)
in a single place, and using an off-the-shelf solution
that complies with these regulations can save a lot of time and resources.</p>
<p>Using a standard compliant SSO server also provides the advantage
of easy substitution with an alternative solution
that adheres to the same standards. In addition,
having a standard compliant SSO server makes it easier
to test and compare different solutions.
For instance, I created an <a href="https://oauth-testbed.luke10x.com/">OAuth Testbed</a>
web application that can be used to test swapping one
OpenID Connect compliant solution for another.</p>
<h3>3. Design Systems</h3>
<p>Design Systems have become an essential part of modern software development.
They provide a consistent set of visual and functional elements
that can be reused across multiple products, or in our case across several Microfrontends.</p>
<p>Design systems offer several advantages, including:</p>
<ul>
<li><em>Rapid application development</em>: Developers can quickly create new features
and components without needing to involve designers
in every aspect of the development process.</li>
<li><em>Consistent look and feel</em> for the entire user journey,
which is especially important when users interact with multiple applications
or platforms from the same brand or organization.</li>
<li>Adhere to <em>accessibility</em> guidelines and best practices
that can help developers create interfaces
that are easy to use for people with disabilities.</li>
</ul>
<p>A component library lies at the core of a Design System.
It offers a set of pre-designed UI components
that can be utilized in multiple applications.
There are many popular component libraries available in the market,
some of which include:</p>
<ul>
<li><em>Material-UI</em>: one of the most popular React component libraries
based on Google's Material Design system.
It provides a rich set of pre-built components,
including buttons, forms, typography, and icons.</li>
<li><em>Bootstrap</em>: one of the oldest and most popular component libraries.
It provides a set of CSS and JavaScript components for building responsive,
mobile-first web applications.</li>
<li><em>Ant Design</em>: a popular Chinese React UI library
that provides a set of high-quality components and a clean design system.
It includes components like buttons, forms, navigation, and data visualization.</li>
<li><em>Semantic UI</em>: a comprehensive component library
that provides a semantic and responsive design system.
It includes a wide range of components, including buttons, forms, and layouts.</li>
<li><em>Chakra UI</em>: a popular React component library
that provides a set of accessible and customizable components.
It includes components like buttons, forms, and typography.</li>
</ul>
<p>As the demand for scalable and consistent design systems grows,
I predict that we will see an increase in the number
of component libraries available.
Despite the popularity of existing component libraries,
each has its own limitations and drawbacks.</p>
<p>Design system discussions often include mentioning
<a href="https://storybook.js.org">Storybook</a>.
Storybook is an open-source tool for building UI components and pages in isolation.
It provides a sandboxed environment where developers can experiment with components
and see how they interact with different data sets and states.</p>
<p>It's not uncommon to see companies over-invest in their design system,
which can lead to wasted resources and slow down development.
Therefore, it's crucial for companies
to make a realistic assessment of their capabilities
and needs before embarking on a design system project.
It's important to consider factors such as the size of the company,
the complexity of the application, the available resources,
and the overall business goals.</p>
<p>For some lean enterprises, having a CSS toolkit like
<a href="https://tailwindcss.com/">TailwindCSS</a>
could be sufficient for their needs.
TailwindCSS provides a set of pre-designed CSS classes
that can be used to style UI components quickly
and consistently across applications.</p>
<ul>
<li><em>Utility-first approach</em>: TailwindCSS follows a utility-first approach,
which means that it provides a set of pre-defined classes
for common styles and layout,
allowing developers to quickly style their components
by applying classes rather than writing custom CSS.</li>
<li><em>Customization</em>: TailwindCSS allows developers to easily customize
their styles by modifying the default theme or creating a new one.
This provides greater flexibility
and control over the design of the application.</li>
<li><em>Size</em>: TailwindCSS is significantly smaller in size compared to Bootstrap,
which means that it can be loaded faster
and has a smaller footprint on the application.
This can be especially important for applications
that prioritize performance and speed.</li>
</ul>
<p>One of the aspects I particularly admire about TailwindCSS
is its utility-first approach.
This approach challenges the traditional &quot;separation of concerns&quot; principle
by promoting a more pragmatic &quot;principle of collocation&quot;.
With TailwindCSS, the styles are defined directly in the markup,
and it also encourages extracting reusable components.</p>
</div><div class="flex space-x-4"><a class="before:absolute before:-left-2" href="/">⬅ back</a></div></div></main><footer class="bg-slate-200 mt-8 py-4"><div class="container mx-auto flex justify-center">© 2023 Luke 10X</div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontmatter":{"slug":"/blog/3-must-haves-for-slicing-monolith-frontend","date":"2023-03-28","title":"3 Must-Have Prerequisites for Slicing Monolith","socialImage":"social-img/3-microfrontend-principles.png","draft":false},"content":"\n## (Frontend journey through Digital Transformation)\n\nOnce a startup has validated the profitability of its idea, \nit typically evolves into a mid-sized company, \nhaving moved rapidly from inception to this point. \nThe product and brand are now well-established in the market, \nbut the next challenge is to compete effectively by adding new features. \nHowever, the technology underpinning the product \ncan become a significant obstacle - a big ball of mud, also known as a monolith.\n\nDespite the company's stable position in the market,\nthe need to deliver new features rapidly has only intensified. \nHowever, there are several challenges hindering progress: \nfirstly, the company has accrued significant technical debt \ndue to its focus on fast prototyping and organic growth; \nsecondly, poor architectural decisions have led to siloed \nand problematic systems; \nand thirdly, customer needs have evolved since the company's inception, \nnecessitating a more responsive approach. \n\nThese challenges can only be met by embarking on a gradual digital transformation, \nmigrating the risky and hard-to-change technical stack \nto better align with business needs \nwhile simultaneously streamlining it for future adaptability\nat the same time ensuring smooth execution of existing business.\n\nMonoliths can pose significant risks, \nas they often become difficult and slow to change over time. \nMaking changes to a monolithic architecture \ntypically requires extensive testing and development cycles, \nleading to delays in time-to-market and the risk of \nintroducing new bugs or technical debt. \n\n*Vertical slicing* is a technique that addresses these issues \nby breaking down a monolith into smaller, more manageable pieces, \nwhich can be developed and tested independently. \nBy focusing on one vertical slice at a time, \ndevelopment teams can streamline development cycles\nand introduce new features and capabilities more rapidly. \nIt's no surprise, then, that vertical slicing is often \nat the core of digital transformation efforts.\n\nWe have become adept at implementing bounded contexts \nand slicing monoliths into microservices in the backend. \nOver the past two decades, \nwe have learned how to create scalable and maintainable architectures, \nleveraging buzzwords such as \nCloud, scalability, CI/CD Pipelines, High availability, \nCQRS, Messaging, Domains, Context Mapping, Caching, and more. \nHowever, while we have established a stable set of best practices in the backend, \nthe frontend and user experience part has often been neglected.\n\nLuckily, over the past several years, \nthere have been significant developments in the user-facing area as well.\nNew best practices have emerged and become more stable, \nallowing for better user experiences and front-end development.\nFrom my experience, I can see three main aspects \nthat have had the biggest impact \non improving the front-end development process and user experience: \nmicrofrontends, single sign-on, and design systems. \nThese aspects have become crucial prerequisites in achieving a successful digital transformation.\n\n### 1. Microfrontends\n\nMicroservices are all about the backend, \nbut historically we didn't have a clear trend \nfor how to do vertical slicing in the frontend. \nIt wasn't clear if we should go with *server-side includes*, \nor *client-side includes*, (and hopefully not with iframes).\n\nThere were some attempts by companies to organize frontend development \nthat have emerged in recent years:\n\n  - *Zalando Tailor*: This is a microfrontend framework developed by Zalando, \n    the European online fashion retailer. \n    Tailor allows for the creation of independent microfrontends \n    that can be integrated into a single page using server-side composition. \n    It also includes features such as shared dependencies, \n    state management, and cross-microfrontend communication.\n\n  - *Spotify Backstage*: Backstage is an open-source platform developed by Spotify \n    to manage their internal tooling and services. \n    It includes a plugin system for adding custom features \n    and a frontend development kit called Backstage-UI, \n    which follows a microfrontend architecture.\n\n  - *Bit*: Bit is an open-source tool \n    for sharing and reusing React components across projects. \n    It allows you to build, test, and deploy individual components, \n    making it easier to manage your codebase and collaborate with other developers.\n\n  - *Open Components*: Open Components is a platform-agnostic library \n    of reusable UI components built with modern web technologies. \n    It provides a set of building blocks for building web applications, \n    making it easier to maintain consistency across your codebase.\n\nJavaScript-based single-page apps have become the norm in web development, \nand regardless of which framework is in use (Angular/React/Vue or any other), \nthey all rely on Webpack. \n\nAs of version 5, Webpack now supports **Federated Modules**, \nwhich is becoming the next big thing \ngiven its strategically-centered position within the JavaScript ecosystem. \n\nI think that Federated Modules will become the dominant way\nof organizing frontend applications \ninto separately released microfrontends for several reasons. \n\n1. It is *framework agnostic* and can integrate at the DOM level using browser APIs,\n  making it adaptable to different projects and technologies (Angular/React/Vue/others);\n2. It supports *state management* and communication channels between microfrontends, \n   making it easier to maintain consistency and coherence across different components;\n3. Webpack has a unique position in the ecosystem,\n   and Federated Modules have *strong community support*, \n   which means that it will continue to improve and evolve over time;\n4. Federated Modules are *very well designed*, making it easy to use and understand,\n   even for developers who are new to the concept of microfrontends.\n\n### Single Sign-On (SSO)\n\nOne of the most obvious challenges that arise when we slice \nour monolithic user experience into microfrontends \nis the need to direct users from one domain to another \nwhile interacting with the system. \nIn most cases, these domains are hosted on different microfrontends, \nwhich means that users would need to log in separately \nto each of the systems they interact with. \n\nThis is where Single Sign-on (SSO) comes into play. \nSSO enables users to jump from one frontend app to another \nwithout the need to log in to each system separately. \nWith SSO, users can authenticate once and access multiple applications \nwithout the need to repeat the login process. \n\nThis is not a new problem, \nsince we had distributed systems and third party integrations since forever.\nIn the past, SSO was often seen as a complex and challenging task, \nrequiring a lot of custom development work. However, in recent years, \nthere has been a growing trend towards standardization and simplification in this area.\nMany popular identity providers, such as Google, Facebook, and Microsoft, \nnow offer easy-to-use APIs and SDKs for implementing SSO. \nIn addition, there are now many open-source and commercial solutions available \nfor implementing SSO, such as Auth0, Okta, and Keycloak, \nwhich can greatly simplify the task \nof integrating SSO into a microfrontends architecture. \nAs a result, SSO has become more accessible \nand easier to implement than ever before.\n\nUsing off-the-shelf solutions that adhere to industry standards \nis highly recommended in the context of Microfrontends development. \nIn contrast, rolling out your own Sign-On solution \nmay not align with the Microfrontends approach to software development \nand could be perceived as a not-invented-here fallacy.\n\nDealing with extensive security and regulatory requirements is a challenging task, \nand rolling out your own Sign-On solution would require a tremendous amount of work. \nImplementing multi-factor authentication (MFA), user registration, management, \nand reset password scenarios could be time-consuming, \nand it's crucial to adhere to regulations such as Open Banking and GDPR, \nwhere security is paramount. \nIt's important to store user PPI (Personally Identifiable Information) \nin a single place, and using an off-the-shelf solution \nthat complies with these regulations can save a lot of time and resources.\n\nUsing a standard compliant SSO server also provides the advantage \nof easy substitution with an alternative solution \nthat adheres to the same standards. In addition, \nhaving a standard compliant SSO server makes it easier \nto test and compare different solutions. \nFor instance, I created an [OAuth Testbed](https://oauth-testbed.luke10x.com/)\nweb application that can be used to test swapping one \nOpenID Connect compliant solution for another.\n\n### 3. Design Systems\n\nDesign Systems have become an essential part of modern software development.\nThey provide a consistent set of visual and functional elements \nthat can be reused across multiple products, or in our case across several Microfrontends.\n\nDesign systems offer several advantages, including:\n\n- *Rapid application development*: Developers can quickly create new features \n  and components without needing to involve designers \n  in every aspect of the development process. \n- *Consistent look and feel* for the entire user journey, \n  which is especially important when users interact with multiple applications \n  or platforms from the same brand or organization. \n- Adhere to *accessibility* guidelines and best practices \n  that can help developers create interfaces \n  that are easy to use for people with disabilities.\n\nA component library lies at the core of a Design System. \nIt offers a set of pre-designed UI components \nthat can be utilized in multiple applications.\nThere are many popular component libraries available in the market, \nsome of which include:\n\n- *Material-UI*: one of the most popular React component libraries \n  based on Google's Material Design system. \n  It provides a rich set of pre-built components, \n  including buttons, forms, typography, and icons.\n- *Bootstrap*: one of the oldest and most popular component libraries. \n  It provides a set of CSS and JavaScript components for building responsive, \n  mobile-first web applications.\n- *Ant Design*: a popular Chinese React UI library \n  that provides a set of high-quality components and a clean design system. \n  It includes components like buttons, forms, navigation, and data visualization.\n- *Semantic UI*: a comprehensive component library \n  that provides a semantic and responsive design system.\n  It includes a wide range of components, including buttons, forms, and layouts.\n- *Chakra UI*: a popular React component library \n  that provides a set of accessible and customizable components. \n  It includes components like buttons, forms, and typography.\n\nAs the demand for scalable and consistent design systems grows,\nI predict that we will see an increase in the number \nof component libraries available. \nDespite the popularity of existing component libraries, \neach has its own limitations and drawbacks.\n\nDesign system discussions often include mentioning \n[Storybook](https://storybook.js.org). \nStorybook is an open-source tool for building UI components and pages in isolation. \nIt provides a sandboxed environment where developers can experiment with components \nand see how they interact with different data sets and states.\n\nIt's not uncommon to see companies over-invest in their design system, \nwhich can lead to wasted resources and slow down development. \nTherefore, it's crucial for companies \nto make a realistic assessment of their capabilities \nand needs before embarking on a design system project. \nIt's important to consider factors such as the size of the company, \nthe complexity of the application, the available resources, \nand the overall business goals.\n\nFor some lean enterprises, having a CSS toolkit like \n[TailwindCSS](https://tailwindcss.com/) \ncould be sufficient for their needs. \nTailwindCSS provides a set of pre-designed CSS classes \nthat can be used to style UI components quickly \nand consistently across applications. \n\n- *Utility-first approach*: TailwindCSS follows a utility-first approach, \n  which means that it provides a set of pre-defined classes \n  for common styles and layout, \n  allowing developers to quickly style their components \n  by applying classes rather than writing custom CSS.\n- *Customization*: TailwindCSS allows developers to easily customize \n  their styles by modifying the default theme or creating a new one. \n  This provides greater flexibility \n  and control over the design of the application.\n- *Size*: TailwindCSS is significantly smaller in size compared to Bootstrap,\n  which means that it can be loaded faster \n  and has a smaller footprint on the application. \n  This can be especially important for applications \n  that prioritize performance and speed.\n\nOne of the aspects I particularly admire about TailwindCSS \nis its utility-first approach. \nThis approach challenges the traditional \"separation of concerns\" principle \nby promoting a more pragmatic \"principle of collocation\". \nWith TailwindCSS, the styles are defined directly in the markup,\nand it also encourages extracting reusable components.\n"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"3-must-haves-for-slicing-monolith-frontend"},"buildId":"jxg3s3yU4HdFy4I86wlDI","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>